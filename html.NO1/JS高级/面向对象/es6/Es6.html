<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
    // {
    // let a = 10;
    // var b = 1;
    // }
    // //    console.log(a)// ReferenceError: a is not defined
    //    console.log(b)//1
    //    for (let i = 0; i <5; i++) {
    //     console.log(i)//0,1,2,3,4 
    //    }

    //    console.log(i);   //i is not defined

    //    var a = [];
    //     for (var i = 0; i < 10; i++) {
    //         a[i] = function () {
    //             console.log(i);
    //         };
    //     }
    //     a[1](); //10


    //     var a = [];
    //     for (let i = 0; i < 10; i++) {
    //         a[i] = function () {
    //             console.log(i);
    //         };
    //     }
    //     a[6](); // 6  块级作用域


    //     console.log(foo); // 输出undefined
    //     // console.log(bar); // 报错ReferenceError  不能进行变量提升

    //     var foo = 2;
    //     let bar = 2;



    //     function temp () {
    //     let a = 10;
    //     var a = 1;
    //     }

    //     // 报错      不能重复定义
    //     function temp () {
    //     let a = 10;
    //     let a = 1;
    //     }



    //     //const声明一个只读的常量。一旦声明，常量的值就不能改变。
    //     const PI = 3.1415;
    //         PI // 3.1415

    //         // PI = 3;
    //         // TypeError: Assignment to constant variable.


//解构赋值
//             let [fol, [[bar1], baz]] = [1, [[2], 3]];
//                 fol // 1
//                 console.log(bar1) // 2
//                 baz // 3

//             let [ , , third] = ["foo", "bar", "baz"];
//                 third // "baz"  
//             let [x, , y] = [1, 2, 3];
//                 x // 1
//                 y // 3  
//             let [head, ...tail] = [1, 2, 3, 4];
//                 head // 1
//                 tail // [2, 3, 4]   

//             let [x1, y1, ...z1] = ['a'];
//                 x1 // "a"
//                 y1 // undefined  如果解构不成功，变量的值就等于undefined。
//                 z1 // []    
//             var [foo = true] = [];
//                 foo // true

//                 [x, y = 'b'] = ['a']; // x='a', y='b'
//                 [x, y = 'b'] = ['a', undefined]; // x='a', y='b'     解构赋值允许指定默认值。


// //对象的解构赋值    
//     var { foo, bar } = { foo: "aaa", bar: "bbb" };
//         foo // "aaa"
//         bar // "bbb" 
//         //对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；
//         //而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。
//         var { bar, foo } = { foo: "aaa", bar: "bbb" };
//             foo // "aaa"
//             bar // "bbb"

//         var { baz } = { foo: "aaa", bar: "bbb" };
//             baz // undefined   
//         var { foo: baz } = { foo: 'aaa', bar: 'bbb' };
//             baz // "aaa"

//         let obj = { first: 'hello', last: 'world' };
//         let { first: f, last: l } = obj;
//             f // 'hello'
//             l // 'world'
//         var obj = {
//             p: [
//                 'Hello',
//                 { y: 'World' }
//             ]
//         };

//         var { p: [x, { y }] } = obj;
//         x // "Hello"
//         y // "World"           //和数组一样，解构也可以用于嵌套结构的对象。
//         var node = {
//             loc: {
//                 start: {
//                 line: 1,
//                 column: 5
//                 }
//             }
//         };

//         var { loc: { start: { line }} } = node;
//             line // 1
//             loc  // error: loc is undefined
//             start // error: start is undefined  只有line是变量，loc和start都是模式，不会被赋值。

//         let obj = {};
//         let arr = [];

//         ({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });

//             obj // {prop:123}
//             arr // [true]  
//         //对象的解构也可以指定默认值。    
//         var {x = 3} = {};
//             x // 3

//         var {x, y = 5} = {x: 1};
//             x // 1
//             y // 5

//         var {x:y = 3} = {};
//             y // 3

//         var {x:y = 3} = {x: 5};
//             y // 5

//         var { message: msg = 'Something went wrong' } = {};
//             msg // "Something went wrong"


//         //   默认值生效的条件是，对 象的属性值严格等于undefined。   
//         var {x = 3} = {x: undefined};
//             x // 3

//         var {x = 3} = {x: null};
//             x // null   
//     //includes()：返回布尔值，表示是否找到了参数字符串。
//     //startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。
//     //endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。  
//     //repeat():   方法返回一个新字符串，表示将原字符串重复n次。
//     //padStart(),padEnd():一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。

//     'x'.repeat(3) // "xxx"
//     'hello'.repeat(2) // "hellohello"
//     'na'.repeat(0) // "" 
//     'na'.repeat(2.9) // "nana"  参数如果是小数，会被取整。
//     'na'.repeat(Infinity)// RangeError
//     'na'.repeat(-1)// RangeError    如果repeat的参数是负数或者Infinity，会报错。
//     'na'.repeat(-0.9) // ""         但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于-0，repeat视同为0。
//     'na'.repeat(NaN) // ""          参数NaN等同于0。
//     'na'.repeat('na') // ""         如果repeat的参数是字符串，则会先转换成数字。
//     'na'.repeat('3') // "nanana"


//     var s = 'Hello world!';

//         s.startsWith('Hello') // true
//         s.endsWith('!') // true
//         s.includes('o') // true 
//     var s = 'Hello world!';

//         s.startsWith('world', 6) // true
//         s.endsWith('Hello', 5) // true
//         s.includes('Hello', 6) // false  

//     'x'.padStart(5, 'ab') // 'ababx'
//     'x'.padStart(4, 'ab') // 'abax'

//     'x'.padEnd(5, 'ab') // 'xabab'
//     'x'.padEnd(4, 'ab') // 'xaba' 
//     'xxx'.padStart(2, 'ab') // 'xxx'
//     'xxx'.padEnd(2, 'ab') // 'xxx'          如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。
//     'abc'.padStart(10, '0123456789')   // '0123456abc'   如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。
//     'x'.padStart(4) // '   x'
//     'x'.padEnd(4) // 'x   '           如果省略第二个参数，则会用空格补全长度。


  var json={
      name:'zsm',
      sex:'女',
      age:21
  }
  let num=1
  console.log(`我的名字是${json.name},num=${num}`)
  var name = "Bob", time = "today";
  console.log(`Hello ${name}, how are you ${time}?`)

//Array.of方法用于将一组值，转换为数组。
//Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。  
//find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。    
   
    Array.of(3, 11, 8) // [3,11,8]
    Array.of(3) // [3]
    Array.of(3).length // 1 


    Array() // []                  Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。
    Array(3) // [, , ,]
    Array(3, 11, 8) // [3, 11, 8]

    Array.of() // []
    Array.of(undefined) // [undefined]
    Array.of(1) // [1]
    Array.of(1, 2) // [1, 2]

    function ArrayOf(){
        return [].slice.call(arguments);
    }
    ArrayOf()


    let arrayLike = {
        '0': 'a',
        '1': 'b',
        '2': 'c',
        length: 3
    };

    // ES5的写法
    var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']

    // ES6的写法
    let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']

    Array.from('hello')// ['h', 'e', 'l', 'l', 'o']

    let namesSet = new Set(['a', 'b'])
    Array.from(namesSet) // ['a', 'b']

    Array.from([1, 2, 3])// [1, 2, 3]       如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。

    [1, 4, -5, 10].find((n) => n < 0)// -5
    [1, 5, 10, 15].find(function(value, index, arr) {
        return value > 9;
    }) // 10
    
    
    
    
    
    
    
    
    </script>
</body>
</html>